### \* Iterating over arrays

- for loop
- for of (Array, String, Map, Set, arguments)
- while loop
- forEach method
- every method
- map
- filter
- reduce
- some

### \* Iterating over objects

#### Using a for...in loop

This method works in all modern and old browsers including Internet Explorer 6 and higher.
One problem in using the `for...in` method is that it loops through the properties
in the prototype chain as well. Since the objects in JavaScript can inherit properties
from their prototypes, the for...in statement will loop through those properties as well.

To avoid this problem, you have to explicitly check if the property belongs to
the object by using the `hasOwnProperty()` method:

```typescript
for (const key in user) {
  if (user.hasOwnProperty(key)) {
    console.log(`${key}: ${user[key]}`);
  }
}
```

To overcome this hassle, later in ES8, two other methods were added, `Object.entries()`
and `Object.values()`.

#### Object.keys method

Before ES6, the only way to loop through an object was through using the `for...in` loop.
The `Object.keys()` method was introduced in ES6 to make it easier to loop over objects.

It takes the object that you want to loop over as an argument and returns an
array containing all properties names (or keys).

```typescript
const keys = Object.keys(courses);
keys.forEach((key, index) => {
  console.log(`${key}: ${courses[key]}`);
});
```

#### Object.values method

The `Object.values()` method was introduced in ES8, and it works opposite to that of `Object.key()`.
It returns the values of all properties in the object as an array.
You can then loop through the values array by using any of the array looping methods.

```typescript
Object.values(animals).forEach((val) => console.log(val));
```

#### Object.entries method

The Object.entries(), another ES8 method can be used for traversing an array.
Object.entries() outputs an array of arrays, with each inner array having two elements.
The first element being the property and the second element is the value.

```typescript
// `for...of` loop
for (const [key, value] of Object.entries(animals)) {
  console.log(`${key}: ${value}`);
}

// `forEach()` method
Object.entries(animals).forEach(([key, value]) => {
  console.log(`${key}: ${value}`);
});
```

### \* for of vs for in

- `for in` loops over enumerable property names of an object (old, do not use).
- `for of` (new in ES6) does use an object-specific iterator (`[Symbol.iterator]`)
  and loops over the values generated by that.

The most common application of `for...of` is iteration over the items of an array.
The cycle does it nicely and shortly, without the need of additional variables to keep an index.

```typescript
var arr = [3, 5, 7];
arr.foo = 'hello';

for (var i in arr) {
  console.log(i); // logs "0", "1", "2", "foo"
}

for (var i of arr) {
  console.log(i); // logs "3", "5", "7"
  // it doesn't log "3", "5", "7", "hello"
}
```

### \*\*\* [Iterators](https://javascript.info/iterable)

To make the `object` iterable (and thus let `for..of` work) we need to add a method to the object
named `Symbol.iterator` (a special built-in symbol just for that).

1. When `for..of` starts, it calls that method once (or errors if not found).
   The method must return an _iterator_ – an object with the method `next()`.
2. Onward, `for..of` works only with that returned object.
3. When `for..of` wants the next value, it calls `next()` on that object.
4. The result of `next()` must have the form `{done: Boolean, value: any}:: IteratorResult`,
   where `done=true` means that the loop is finished, otherwise `value` is the next value.

```typescript
function range(from: number, to: number) {
  return {
    from: from,
    to: to,
    [Symbol.iterator]() {
      return {
        current: this.from,
        last: this.to,
        next() {
          if (this.current <= this.last) {
            return { done: false, value: this.current++ };
          } else {
            return { done: true, value: this.current };
          }
        },
      };
    },
  };
}
```

The iterator object is separate from the object it iterates over.

String is iterable. For a string, `for..of` loops over its characters.

#### Iterables and array-likes

Two official terms look similar, but are very different:

- Iterables are objects that implement the `Symbol.iterator` method, as described above.
- Array-likes are objects that have indexes and `length`, so they look like arrays.

#### Array.from

There’s a universal method `Array.from` that takes an iterable or array-like value
and makes a “real” Array from it. Then we can call array methods on it.

```typescript
let arrayLike = {
  0: 'Hello',
  1: 'World',
  length: 2,
};

let arr = Array.from(arrayLike); // (*)
alert(arr.pop()); // World (method works)
```

The optional second argument `mapFn` can be a function that will be applied to each
element before adding it to the array, and `thisArg` allows us to set `this` for it.

```typescript
// Array.from(obj[, mapFn, thisArg])
// Assuming that range is taken from the example above.
// Square each number.
let arr = Array.from(range, (num) => num * num);
alert(arr); // 1,4,9,16,25
```

#### Async iterables

Asynchronous iteration is needed when values come asynchronously: after `setTimeout` or another
kind of delay. The most common case is that the object needs to make a network request to
deliver the next value. To make an object iterable asynchronously:

- Use `Symbol.asyncIterator` instead of `Symbol.iterator`.
- The `next()` method should return a `promise` (to be fulfilled with the next value).
  The `async` keyword handles it, we can simply make `async next()`.
- To iterate over such an object, we should use a `for await (let item of iterable)` loop.
  Note the `await` word.

```typescript
let range = {
  from: 1,
  to: 5,

  [Symbol.asyncIterator]() {
    // (1)
    return {
      current: this.from,
      last: this.to,

      async next() {
        // (2)

        // note: we can use "await" inside the async next:
        await new Promise((resolve) => setTimeout(resolve, 1000)); // (3)

        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      },
    };
  },
};

(async () => {
  for await (let value of range) {
    // (4)
    alert(value); // 1,2,3,4,5
  }
})();
```

As we can see, the structure is similar to regular iterators:

1. To make an object asynchronously iterable, it must have a method `Symbol.asyncIterator` `(1)`.
2. This method must return the object with `next()` method returning a `promise` `(2)`.
3. The `next()` method doesn’t have to be `async`, it may be a regular method returning a `promise`,
   but `async` allows us to use `await`, so that’s convenient. Here we just delay
   for a second `(3)`.
4. To iterate, we use for await(let value of range) `(4)`, namely add “await” after “for”.
   It calls `range[Symbol.asyncIterator]()` once, and then its `next()` for values.

|                                   | Iterators         | Async iterators        |
| --------------------------------- | ----------------- | ---------------------- |
| Object method to provide iterator | `Symbol.iterator` | `Symbol.asyncIterator` |
| `next()` return value is          | any value         | `Promise`              |
| to loop, use                      | `for..of`         | `for await..of`        |

> The spread syntax `...` doesn’t work asynchronously
